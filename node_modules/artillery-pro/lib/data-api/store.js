/** @license
 * (c) 2021 Shoreditch Ops Ltd. All rights reserved.
 *
 * This file is part of Artillery Pro (https://artillery.io)
 *
 * NOTICE: All information contained herein is, and remains
 * the property of Shoreditch Ops Ltd. The intellectual and
 * technical concepts contained herein are proprietary to
 * Shoreditch Ops Ltd and are protected by copyright law.
 *
 * Modification and/or redistribution of this material is
 * strictly forbidden unless prior written permission is
 * obtained from Shoreditch Ops Ltd.
 *
 */
const debug=require("debug")("store"),_=require("lodash"),{listAllObjectsWithPrefix,getBucketName}=require("../util"),{promisify}=require("util"),{ObjectStore}=require("../cloud/object-store"),util=require("util"),{TestRunObject}=require("./test-run-object"),uuidv4=require("uuid/v4");class S3Store{constructor(){return this.bucketName=null,this}async init(){return this.bucketName||(this.bucketName=await getBucketName()),this}async listTestRuns(tags,limit,offset){let ids=[];try{const results=await promisify(listAllObjectsWithPrefix)(this.bucketName,"db/test-runs");ids=results.map(x=>x.Key).map(components=>{components=components.split("/");return{id:components[2],endedAt:Number(components[3])}}),debug({ids:ids})}catch(err){throw err}if(0===tags.length)return ids;let taggedIds=[],results2=[];try{for(const tag of tags){const prefix=`db/tag-to-test-run-id/${tag.name}:${tag.value}___`,objects=await promisify(listAllObjectsWithPrefix)(this.bucketName,prefix);debug({objects:objects}),taggedIds.push(objects.map(x=>x.Key.split("___")[1]))}debug({taggedIds:taggedIds}),taggedIds=_.intersection(...taggedIds);for(const id of taggedIds){const res=await promisify(listAllObjectsWithPrefix)(this.bucketName,`db/test-runs/${id}`);var components=res[0].Key.split("/");results2.push({id:components[2],endedAt:Number(components[3])})}}catch(err){throw err}return results2}async getTestRun(testId){const result={metadata:{},tasks:[],report:{},consoleLog:null,status:null},store=new ObjectStore({backend:"aws",bucket:this.bucketName});var prefix=`test-runs/${testId}`;try{const results=await promisify(listAllObjectsWithPrefix)(this.bucketName,prefix);debug(results.map(x=>x.Key))}catch(err){throw err}try{var metadata=await store.get(`${prefix}/metadata.json`,{json:!0});result.metadata=metadata}catch(err){debug(err)}try{var tasks=await store.get(`${prefix}/tasks.json`,{json:!0});result.tasks=tasks}catch(err){debug(err)}try{var report=await store.get(`${prefix}/report.json`,{json:!0});result.report=report}catch(err){debug(err)}try{var notes=await this.getNotes(testId);result.notes=notes}catch(err){debug(err)}try{var consoleLogJson=await store.get(`${prefix}/console-output.json`,{json:!0});let consoleLog="";for(const args of consoleLogJson)consoleLog+=util.format(...Object.keys(args).map(k=>args[k]))+"\n";result.consoleLog=consoleLog}catch(err){debug(err)}try{var status=await store.get(`${prefix}/status.json`,{json:!0});result.status=status}catch(err){debug(err)}return result}async listTags(){try{const results=await promisify(listAllObjectsWithPrefix)(this.bucketName,"db/tags");var tags=results.map(x=>x.Key).map(name=>{var value=name.split("/");if(3===value.length){const tagstring=value[2];var[name,value]=tagstring.split(":");return{name:name,value:value}}}).filter(x=>x);return debug({tags:tags}),tags}catch(err){throw err}}async addNote(testRunId,text,opts){try{const store=new ObjectStore({backend:"aws",bucket:this.bucketName});var noteId=uuidv4();return await store.put(`db/notes/${testRunId}/${Date.now()}_${noteId}`,text),noteId}catch(err){throw err}}async _listNotes(testRunId){try{var prefix=`db/notes/${testRunId}/`;const results=await promisify(listAllObjectsWithPrefix)(this.bucketName,prefix);return results.map(metadata=>{metadata=metadata.Key.split(`db/notes/${testRunId}/`)[1].split("_");return{id:metadata[1],createdOn:Number(metadata[0])}})}catch(err){throw err}}async getNotes(testRunId){const notes=[];try{const store=new ObjectStore({backend:"aws",bucket:this.bucketName});for(const n of await this._listNotes(testRunId)){var key=`db/notes/${testRunId}/${n.createdOn}_${n.id}`,text=(await store.get(key,{json:!1})).Body.toString();notes.push({createdOn:n.createdOn,id:n.id,text:text})}return notes}catch(err){throw err}}}const AWS=require("aws-sdk"),getrc=require("../utils/get-rc"),{getAccountId}=require("../util");class DynamoStore{constructor(opts){return this}async init(){var accountId;return this.tableName||(accountId=await getAccountId(),this.tableName=`artilleryio-test-runs-${accountId}`,this.commonObjectsTable=`artilleryio-common-objects-${accountId}`),this.region=(await getrc()).backendRegion,AWS.config.update({region:this.region}),this.ddb=new AWS.DynamoDB.DocumentClient({apiVersion:"2012-08-10"}),this}async getRunningTests(){try{var statuses=["INITIALIZING","LAUNCHING_WORKERS","RECEIVING_REPORTS"];const params={TableName:this.tableName,IndexName:"test-runs-laststatus-index",KeyConditions:{statusName:{ComparisonOperator:"EQ",AttributeValueList:[]}}};let items=[];for(const s of statuses){params.KeyConditions.statusName.AttributeValueList=[s];var data=await this.ddb.query(params).promise();items=items.concat(data.Items)}let result={};for(const item of items){var testRunId=item.testRunId,testRunData=await this.getTestRun(testRunId);result[testRunId]={testId:testRunId,region:testRunData.metadata.region,cluster:testRunData.metadata.cluster,launchType:testRunData.metadata.launchType,count:testRunData.metadata.count,startedAt:testRunData.metadata.startedAt,lastStatus:item.statusName}}return result}catch(err){throw err}}async listTestRuns(tags,limit,offset){try{const params={TableName:this.tableName,IndexName:"test-runs-createdtime-index",KeyConditions:{kind:{ComparisonOperator:"EQ",AttributeValueList:["createdTime"]},createdTime:{ComparisonOperator:"BEGINS_WITH",AttributeValueList:["2021"]}},QueryFilter:{testRunId:{ComparisonOperator:"NE",AttributeValueList:["__artilleryio:virtual:key"]}},ScanIndexForward:!1,Limit:100};"object"==typeof offset&&(params.ExclusiveStartKey=offset);const data=await this.ddb.query(params).promise();return debug(data),data.Items.map(item=>({id:item.testRunId,endedAt:Number(new Date(item.createdTime))}))}catch(err){throw err}}async getTestRun(testRunId){const result={metadata:{},tasks:[],report:{intermediate:[],aggregate:{}},consoleLog:null,status:null,notes:null};var data={TableName:this.tableName,KeyConditions:{testRunId:{ComparisonOperator:"EQ",AttributeValueList:[testRunId]}}},data=await this.ddb.query(data).promise();const itemByKind={};for(const item of data.Items){var{kind}=item;itemByKind[kind]=item}result.metadata={testId:itemByKind["metadata#testId"].stringValue,startedAt:itemByKind["metadata#startedAt"].numberValue,cluster:itemByKind["metadata#cluster"].stringValue,region:itemByKind["metadata#region"].stringValue,launchType:itemByKind["metadata#launchType"].stringValue,count:itemByKind["metadata#count"].numberValue,tags:itemByKind.tags?itemByKind.tags.tags.split(",").map(x=>({name:x.split(":")[0],value:x.split(":")[1]})):[]},result.tasks=Object.keys(itemByKind).filter(k=>k.startsWith("metadata#task#")).map(k=>itemByKind[k].value),result.report.intermediate=[].concat(Object.keys(itemByKind).filter(k=>k.startsWith("report#intermediate#")).map(k=>itemByKind[k].data).map(s=>JSON.parse(s))),itemByKind["report#aggregate"]&&(result.report.aggregate=JSON.parse(itemByKind["report#aggregate"].data)),result.consoleLog=Object.keys(itemByKind).filter(k=>k.startsWith("consoleOutput#")).map(k=>JSON.parse(itemByKind[k].data));let consoleLog="";for(const lines of result.consoleLog)for(const args of lines)consoleLog+=util.format(...Object.keys(args).map(k=>args[k]))+"\n";return result.consoleLog=consoleLog,result.status={endedAt:Number(new Date(itemByKind.lastStatus.endTime)),status:itemByKind.lastStatus.statusName},result.notes=await this.getNotes(testRunId),result}async listTags(){var params={TableName:this.tableName,KeyConditions:{testRunId:{ComparisonOperator:"EQ",AttributeValueList:["__artilleryio:virtual:key"]},kind:{ComparisonOperator:"BEGINS_WITH",AttributeValueList:["tag#"]}}};const data=await this.ddb.query(params).promise();return data.Items.map(x=>({name:x.name,value:x.stringValue}))}async addNote(testRunId,note){var noteId=uuidv4(),ts=Date.now();return await this.ddb.put({TableName:this.tableName,Item:{testRunId:testRunId,kind:`note#${ts}`,noteId:noteId,createdTime:new Date(ts).toISOString(),data:note}}).promise(),noteId}async getNotes(testRunId){const data=await this.ddb.query({TableName:this.tableName,KeyConditionExpression:"testRunId = :id AND begins_with(kind, :prefix)",ExpressionAttributeValues:{":id":testRunId,":prefix":"note#"},ScanIndexForward:!1,Limit:10}).promise();return data.Items.map(x=>({createdOn:Number(new Date(x.createdTime)),id:x.noteId,text:x.data}))}}class Store{constructor(backend){return this.backend=new("s3"===backend?S3Store:DynamoStore),this}async init(){return this.backend.init()}async listTestRuns(tags,limit,offset){return this.backend.listTestRuns(tags,limit,offset)}async getTestRun(testRunId){return this.backend.getTestRun(testRunId)}async listTags(){return this.backend.listTags()}async addNote(testRunId,text,opts){return this.backend.addNote(testRunId,text,opts)}async getNotes(testRunId){return this.backend.getNotes(testRunId)}async getRunningTests(){return this.backend.getRunningTests()}}let store;function getOrCreateStore(backend){return store=store||new Store(backend),store}module.exports=getOrCreateStore;