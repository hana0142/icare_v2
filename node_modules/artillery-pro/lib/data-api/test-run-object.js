/** @license
 * (c) 2021 Shoreditch Ops Ltd. All rights reserved.
 *
 * This file is part of Artillery Pro (https://artillery.io)
 *
 * NOTICE: All information contained herein is, and remains
 * the property of Shoreditch Ops Ltd. The intellectual and
 * technical concepts contained herein are proprietary to
 * Shoreditch Ops Ltd and are protected by copyright law.
 *
 * Modification and/or redistribution of this material is
 * strictly forbidden unless prior written permission is
 * obtained from Shoreditch Ops Ltd.
 *
 */

const { ObjectStore } = require('../cloud/object-store');
const { getBucketName, getAccountId } = require('../util');
const getrc = require('../utils/get-rc');
const AWS = require('aws-sdk');
const debug = require('debug')('store');
const uuidv4 = require('uuid/v4');

//
// S3-backed storage for TestRuns
//
class StorageBackendS3 {
  static properties = {
    type: 'aws:s3',
    description: 'AWS S3 storage backend'
  };

  constructor(id, opts) {
    this.id = id;
    return this;
  }

  async init() {
    const bucketName = await getBucketName();
    this.backend = new ObjectStore({ backend: 'aws', bucket: bucketName });
    return this;
  }

  async setEndedAt(ts) {
    // Index of test run IDs
    await this.backend.put(`db/test-runs/${this.id}/${ts}`, '');
  }

  async setTags(tags) {
    // Index of tags
    const updateTags = tags.map(t => {
      return this.backend.put(`db/tags/${t.name}:${t.value}`, '');
    });
    const updateTagsToTestRunIds = tags.map(t => {
      return this.backend.put(`db/tag-to-test-run-id/${t.name}:${t.value}___${this.id}`, '');
    });
    await Promise.all(updateTags);
    await Promise.all(updateTagsToTestRunIds);
  }

  async setReport(report) {
    await this.backend.put(`test-runs/${this.id}/report.json`, JSON.stringify(report));
    return this;
  }

  async setTextLog(lines) {
    await this.backend.put(`test-runs/${this.id}/console-output.json`,
                           JSON.stringify(lines, 4, null));
    return this;
  }

  async setStatus(statusString, ts) {
    await this.backend.put(`test-runs/${this.id}/status.json`,
                           JSON.stringify({
                             ts,
                             status: statusString,
                           }, null, 4));
    return this;
  }

  async setMetadata(metadata) {
    await this.backend.put(`test-runs/${this.id}/metadata.json`, JSON.stringify(metadata));
    await this.backend.put(`index/test-runs/${this.id}/__metadata__.json`, JSON.stringify(metadata));
  }

  async recordTask({clusterName, region, taskArn}) {
    const key = `index/test-runs/${this.id}/__task_id__${clusterName}___${region}___${taskArn}`;
    await this.backend.put(key, '');
    return this;
  }

  async setTasks(taskArns) {
    await this.backend.put(`test-runs/${this.id}/tasks.json`, JSON.stringify(taskArns));
    return this;
  }

  async recordIntermediateReport(report, ts) {
    await this.backend.put(
      `test-runs/${this.id}/intermediates/${Number(new Date(ts))}`,
      JSON.stringify(report));
    return this;
  }
}

//
// DynamoDB-backed storage for TestRuns
//

class StorageBackendDynamo {
  constructor(id, opts) {
    this.id = id;
  }

  static properties = {
    type: 'aws:dynamodb',
    description: 'AWS DynamoDB backend',
  };

  async init() {
    debug('testRunObject init');
    if (!this.tableName) {
      const accountId = await getAccountId();
      this.tableName = `artilleryio-test-runs-${accountId}`;
      this.commonObjectsTable = `artilleryio-common-objects-${accountId}`;
    }

    this.region = (await getrc()).backendRegion;
    AWS.config.update({region: this.region});
    this.ddb = new AWS.DynamoDB.DocumentClient({ apiVersion: '2012-08-10' });
    return this;
  }

  async setEndedAt(ts) {
    debug('testRunObject setEndedAt');
    // Don't need this on Dynamo
    return this;
  }

  async setTags(tags) {
    debug('testRunObject setTags');
    //
    // Set tags for test for this test run:
    //
    const params = {
      TableName: this.tableName,
      Item: {
        testRunId: this.id,
        kind: 'tags',
        tags: tags.map(x => x.name + ':' + x.value).join(',')
      }
    };
    await this.ddb.put(params).promise();

    //
    // Update global list of tags:
    //
    const tagData = tags.map((x) => {
      const r = {
          Item: {
            testRunId: `__artilleryio:virtual:key`,
            kind: `tag#${x.name}:${x.value}`,
            name: x.name,
            valueType: typeof x.value,
          }
        }
      r.Item[`${(typeof x.value)}Value`] = x.value;
      return r;
    });
    debug(tagData);
    const batchWriteRequest = this._makeBatchWriteRequest(this.tableName, tagData);
    debug(JSON.stringify(batchWriteRequest, null, 4));
    await this.ddb.batchWrite(batchWriteRequest).promise();
    return this;
  }

  async setReport({intermediate, aggregate}) {
    debug('testRunObject setReport');
    // Intermediate reports:
    //
    // TODO: Whole thing can't be >400kb
    debug('intermediate:')
    debug(intermediate);
    if (intermediate.length > 0) { // TODO: Why is this sometimes []
      const items = intermediate.map(x => {
        const timestamp = Number(x.period) || x.timestamp; // v2 and v1
        return {
          Item: {
            testRunId: this.id,
            kind: `report#intermediate#${Number(new Date(timestamp))}`,
            data: JSON.stringify(x)
          }
        }
      });
      debug(items);
      const batchWriteRequest = this._makeBatchWriteRequest(this.tableName, items);
      await this.ddb.batchWrite(batchWriteRequest).promise();
    }

    if (aggregate) {
      // Aggregate report:
      await this.ddb.put({
        TableName: this.tableName,
        Item: {
          testRunId: this.id,
          kind: 'report#aggregate',
          data: JSON.stringify(aggregate)
        }
      }).promise();
    }

    return this;
  }

  async setTextLog(lines) {
    debug('testRunObject setTextLog');
    await this.ddb.put({
      TableName: this.tableName,
      Item: {
        testRunId: this.id,
        kind: `consoleOutput#${Date.now()}`,
        data: JSON.stringify(lines)
      }
    }).promise();

    return this;
  }

  async setStatus(statusString, endTime) {
    debug('testRunObject setStatus');
    await this.ddb.put({
      TableName: this.tableName,
      Item: {
        testRunId: this.id,
        kind: 'lastStatus',
        statusName: statusString,
        endTime: new Date(endTime).toISOString() // TODO: endTime -> updatedTime
      }
    }).promise();

    return this;
  }

  async setMetadata(metadata) {
    debug('testRunObject setMetadata');
    const items = [];
    // FIXME: this means metadata has to be a FLAT object, nothing
    // nested inside
    const metadata2 = JSON.parse(JSON.stringify(metadata));
    delete metadata2.tags;

    for (const [key, val] of Object.entries(metadata2)) {
      const r = {
        Item: {
          testRunId: this.id,
          kind: `metadata#${key}`,
          key: key,
          valueType: typeof val
        }
      };
      r.Item[`${typeof val}Value`] = val;
      items.push(r);
    }

    debug(items);

    const batchWriteRequest = this._makeBatchWriteRequest(this.tableName, items);
    await this.ddb.batchWrite(batchWriteRequest).promise();

    // Set createdTime attribute from metadata
    await this.ddb.put({
      TableName: this.tableName,
      Item: {
        testRunId: this.id,
        kind: 'createdTime',
        createdTime: new Date(metadata.startedAt || Date.now()).toISOString(),
      }
    }).promise();

    return this;
  }

  async recordTask(taskInfo) {
    debug('testRunObject recordTask');
    return this.setTasks([taskInfo.taskArn]);

    // await this.ddb.put({
    //   TableName: this.tableName,
    //   Item: {
    //     testRunId: this.id,
    //     kind: `metadata#task#taskArn#${taskInfo.taskArn}`,
    //     value: JSON.stringify(taskInfo)
    //   }
    // }).promise();

    // return this;
  }

  async setTasks(taskArns) {
    debug('testRunObject setTasks');

    const items = taskArns.map((arn) => {
      return {
        Item: {
          testRunId: this.id,
          kind: `metadata#task#${arn}`,
          value: arn
        }
      }
    });

    const batchWriteRequest = this._makeBatchWriteRequest(this.tableName, items);
    await this.ddb.batchWrite(batchWriteRequest).promise();

    return this;

  }

  // ts is an epoch timestamp
  async recordIntermediateReport(report, ts) {
    debug('testRunObject recordIntermediateReport');

    await this.ddb.put({
      TableName: this.tableName,
      Item: {
        testRunId: this.id,
        kind: `report#intermediate#${ts}`,
        data: JSON.stringify(report),
      }
    }).promise();

    return this;
  }

  async addNote(note) {
    debug('testRunObject addNote');

    // Add note to test:
    const ts = Date.now();
    await this.ddb.put({
      TableName: this.tableName,
      Item: {
        testRunId: this.id,
        kind: `note#${ts}`,
        noteId: uuidv4(),
        createdTime: new Date(ts).toISOString(),
        data: note // FIXME: XSS
      },
    }).promise();

    return this;
  }

  _makeBatchWriteRequest(tableName, items) {
    const batchWriteRequest = {
      RequestItems: {}
    };
    batchWriteRequest.RequestItems[tableName] = items.map(i => {
      return { PutRequest: i }
    });
    return batchWriteRequest;
  }
}

class TestRunObject {
  constructor(id, opts = {}) {
    this.id = id;

    if(opts.backend === 's3') {
      this.backend = new StorageBackendS3(id, opts);
    } else {
      this.backend = new StorageBackendDynamo(id, opts);
    }

    // this.attrs = {
    //   id: '',
    //   metadata: {},
    //   jsonReport: '',
    //   tetxLog: '',
    //   notes: '',
    //   tags: [],
    //   status: {},
    // };

    return this;
  }

  async init() {
    await this.backend.init(this.id);
    return this;
  }

  static async get(id) {
  }

  static async list(attrs, limit, offset) {
    // supported attrs: id, tags
  }

  async setEndedAt(ts) {
    this.endedAt = ts;
    await this.backend.setEndedAt(ts);
    return this;
  }

  async setTags(tags) {
    this.tags = tags;
    await this.backend.setTags(tags);
    return this;
  }

  // TODO: This updates in one go, we want to do partial updates for intermediate
  async setReport(intermediateReports, aggregateReport) {
    this.report = {
      intermediate: intermediateReports,
      aggregate: aggregateReport
    };

    await this.backend.setReport(this.report);
    return this;
  }

  async setTextLog(lines) {
    this.textLog = lines;
    await this.backend.setTextLog(lines);
    return this;
  }

  async setStatus(statusString, ts) {
    if(typeof ts === 'undefined') {
      ts = Date.now();
    }
    await this.backend.setStatus(statusString, ts);
    return this;
  }

  async setMetadata(metadata) {
    await this.backend.setMetadata(metadata);
    return this;
  }

  // TODO: Shit name
  async recordTask({clusterName, region, taskArn}) {
    await this.backend.recordTask({clusterName, region, taskArn});
    return this;
  }

  async setTasks(taskArns) {
    await this.backend.setTasks(taskArns);
    return this;
  }

  async recordIntermediateReport(report, ts) {
    await this.backend.recordIntermediateReport(report, ts);
    return this;
  }

  async addNote(note) {
    await this.backend.addNote(note);
    return this;
  }

}

// class QueryS3 {
//   constructor() {

//   }
// }

// class Query {
//   constructor(opts) {
//     if(opts.backend === 'aws:dynamodb') {
//       this.backend = new QueryDynamo(id, opts);
//     } else {
//       this.backend = new QueryS3(id, opts);
//     }
//   }

//   list(tags, limit, offset) {

//   }

//   get() {

//   }
// }

module.exports = {
  TestRunObject,
  // Query,
};
